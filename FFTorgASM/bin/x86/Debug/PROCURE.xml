<?xml version="1.0" encoding="utf-8" ?>
<Patches>
  <Patch name="Formula 0C: +StatusProc, -ElemBoost">
    <Description>
      Main faith-based heal formula has status proc instead of 
      elemental boost (no active heal abilties using this formula 
      have elements anyway)
    </Description>
    <Location file="BATTLE_BIN" offset="121F08" mode="ASM">
      jal     0x188858              # Healing Calculation
      nop
      jal     0x187150              # Faith Calculation
      nop
      jal     0x187350              # Undead Reversal
      nop
      jal     0x187eb4              # Status Proc
      nop
    </Location>
  </Patch>
  <Patch name="Create VOIDBLADE (41)">
    <Description>
      Creates "Voidblade", removing positive statuses and dealing damage. 
      Changes formula 41, used by Galaxy Stop. If using this patch, you 
      will want to change this formula to something else using FFTPatcher.
      (I recommend 50, which is similar, but uses physical evade instead of 
       magic evade, and has no zodiac check.)
    </Description>
    <Location file="BATTLE_BIN" offset="123114" mode="ASM">
      addiu   sp,sp,-0x18
      sw      ra,0x10(sp)
      
      jal     0x188510              # Physical Evade Calculation
      nop
      bne     v0,zero,END           # If Evaded, Skip
      nop
      
      jal     0x185c94              # Get Ability Power
      nop
      jal     0x188964              # Calculate MA * Y Damage
      nop
      lw      v0,0x80192d90         
      li      v1,0x81
      sb      v1,0x25(v0)           # Action type = HP Damage + Status
      jal     0x187eb4              # Apply status (100%)
      nop
      
END:  lw      ra,0x10(sp)
      addiu   sp,sp,0x18
      jr      ra
      nop
    </Location>
  </Patch>
  <Patch name="Steal Exp -> Starblade (28)">
    <Description>
	Changes formula 28 (Steal Exp) into MA*Y life drain
        (magic, ignores undead status). If targetting an area, 
        damage applies to all targets, but HP is only absorbed
        from the last target.
    </Description>
    <Location file="BATTLE_BIN" offset="122870" mode="ASM">
      addiu   sp,sp,-0x18
      sw      ra,0x10(sp)	
      jal     0x188510      	      # Physical Evade Calculation
      nop				
      bne     v0,zero,END		
      nop
      jal     0x185c94		      # Get Ability Power
      nop				
      jal     0x188964		      # Calculate MA * Y Damage
      nop		
      lw      a0,0x80192d90         # a0 = [Ability]
      lw      v1,0x80192d8c		# v1 = [Target unit's ability]							
      lhu     a1,0x04(a0)		# a1 = [Ability's HP Damage]
      li      v0,0x40
      sb      v0,0x25(v1)		# [Set Target unit's ability type to HP Healing]
      sh      a1,0x06(v1)		# [Save a0 as HP Healing of Target unit's ability]
      li      v0,1
      sb      v0,0x00(v1)		# [Target unit's ability: Not evaded]
      
END:  lw      ra,0x10(sp)
      addiu   sp,sp,0x18
      jr      ra				# Return
      nop
    </Location>
  </Patch>
  <Patch name="Formula 3D -> Like 4E, but physical evade">
    <Description>
	Changes formula 3D to MA*Y magic damage, with 
        status proc, and physical evade.
    </Description>
    <Location file="BATTLE_BIN" offset="122FCC" mode="ASM">
      addiu   sp,sp,-0x18
      sw      ra,0x10(sp)
      
      jal     0x188510              # Physical Evade Calculation
      nop
      bne     v0,zero,END           # If Evaded, Skip
      nop
      
      jal     0x185c94              # Get Ability Power
      nop
      jal     0x188964              # Calculate MA * Y damage
      nop
      
      nop
      nop

END:  lw      ra,0x10(sp)
      addiu   sp,sp,0x18
      jr      ra
      nop
    </Location>
  </Patch>
  <Patch name="Disable Faith/Innocent status">
    <Location file="BATTLE_BIN" offset="187150" offsetMode="RAM" mode="ASM">
      b 0x1871f0
    </Location>
    <Location file="BATTLE_BIN" offset="1894A4" offsetMode="RAM" mode="ASM">
      b 0x189548
    </Location>
  </Patch>
  <Patch name="Esuna/Stigma can hit without status cancel">
    <Location file="BATTLE_BIN" offset="121EE0" mode="ASM">
      jal     0x187eb4              # Formula 0D (Esuna): Can hit even if no status canceled
    </Location>
    <Location file="BATTLE_BIN" offset="122E7C" mode="ASM">
      jal     0x187eb4              # Formula 33 (Stigma Magic): Can hit even if no status canceled
    </Location>
  </Patch>
  <Patch name="Jobs [3A,3B] use unit/wldface [08,09]">
    <Description>
      Jobs [3A,3B] use unit/wldface [08,09] for formation screen and battle preparation sprites.
    </Description>
    <Location file="WORLD_WORLD_BIN" offset="458B0"> 
      3C
    </Location>
    <Location file="WORLD_WORLD_BIN" offset="74B88">
      080009
    </Location>
    <Location file="WORLD_WORLD_BIN" offset="AA1DC">
      080009
    </Location>
    <Location file="WORLD_WORLD_BIN" offset="AA92C">
      080009
    </Location>
    <Location file="WORLD_WORLD_BIN" offset="ADE6E">
      0809
    </Location>
    <Location file="EVENT_ATTACK_OUT" offset="16C24">
      080009
    </Location>
  </Patch>
  <Patch name="PROCURE Main ASM">
    <Location file="BATTLE_BIN" offset="F3D4C" mode="ASM">

# Set up some labels
.label  @apply_elemental, 0x186ffc
.label  @apply_damage_healing_multipliers, 0x15d160
.label  @clear_data_block, 0x05e644

.label  @address_field_element, 0x80159f14
.label  @address_tile_element, 0x80159f20
.label  @address_ability_flags, 0x8015a300
.label  @address_processing_data, 0x8015ab10
.label  @address_elemental_shield, 0x8015ab30
.label  @address_enchant_element, 0x8015ab70

# s0 = Processing data change byte
# s1 = Source tile element address
# s2 = Target tile element address
# s3 = Target vulnerability
# s4 = Action
# s5 = Target
# s6 = Flags
# s7 = 0x80190000

# [STACK]:
#   0x40 = Target unit index

@apply_action_flags_pre:

    addiu   sp, sp, -44
    sw      ra, 4(sp)
    sw      s0, 8(sp)
    sw      s1, 12(sp)
    sw      s2, 16(sp)
    sw      s3, 20(sp)
    sw      s4, 24(sp)
    sw      s5, 28(sp)
    sw      s6, 32(sp)
    sw      s7, 36(sp)

    # -- Get parameters --
    lui     s7, 0x8019          #   s7 = 0x80190000
    lw      s4, 0x2d90(s7)      #   s4 = Ability
    lw      s5, 0x2d98(s7)      #   s5 = Target
    nop
    
    #   Save target unit index to stack
    jal     @find_unit_index
    move    a0, s5
    sw      v0, 0x40(sp)
    
    lw      a0, 0x2d94(s7)      #   Parameter a0 = Source
    jal     @get_unit_element_address
    nop
    move    s1, v0              #   s1 = Source tile element address

    jal     @get_unit_element_address
    move    a0, s5              #   Parameter a0 = Target
    move    s2, v0              #   s2 = Target tile element address     
    
    lhu     t1, 0x38d6(s7)      #   Ability ID
    lbu     s3, 0x0169(s5)      #   s3 = Target vulnerability

    sll     t0, t1, 2           #   Ability ID * 4
   
    la      t2, @address_ability_flags
    addu    t2, t2, t1
    lw      s6, 0(t2)           #   s6 = Ability flags (all bytes)

    lbu     t3, 0x38f7(s7)      #   Ability element
    
    la      t5, @address_field_element
    lbu     t4, 0(t5)           #   Field element
    
    # Append enchant element to weapon element
    jal     @get_unit_enchant_element
    move    a0, s5
    
    lbu     t0, 0x3904(s7)      #   Weapon element
    nop
    or      t0, t0, v0          #   Append weapon and enchant elements
    sb      t0, 0x3904(s7)      #   Store as weapon element
    
    li      s0, 0               #   Clear processing change byte
    
    la      t6, @address_processing_data
    
    # --

    #   t0, t1, t2 temp
    #   t3 = Action element
    #   t4 = Field element
    #   t5 = (Target) tile element
    #   t6 = Processing data address
    #   t7 = Critical?
    #   t8 = (Source) tile element
    #   t9 = Bonus applied

    # -- CHECKS --
    
    # Check 4th byte flags
    srl     t0, s6, 24
    
    andi    t1, t0, 0x80        #   Applies positive elemental status?
    beq     t1, zero, aaf_pre_negative_status
    nop
    jal     @apply_elemental_status_positive
    nop
    
    aaf_pre_negative_status:
        andi    t1, t0, 0x40        #   Applies negative elemental status?
        beq     t1, zero, aaf_pre_flags_1
        nop
        jal     @apply_elemental_status_negative
        nop
    
    aaf_pre_flags_1:
        
    andi    t0, s6, 0x0080      #   Acquires field element?
    sll     t0, t0, 24
    sra     t0, t0, 31          
    and     t1, t4, t0          #   If not, no element added
    or      t3, t3, t1          #   Add to element

    andi    t0, s6, 0x0040      #   Acquires (source) tile element?
    lbu     t1, 0(s1)           #   (Source) tile element
    sll     t0, t0, 25          
    sra     t0, t0, 31          
    and     t2, t1, t0          #   If not, no element added
    or      t3, t3, t2          #   Determine action element
    sb      t3, 0x38f7(s7)      #   Store as action element

    andi    t0, s6, 0x0020      #   Spreads element to field?
    sll     t1, t0, 2           
    or      s0, s0, t1          #   Processing change byte
    sll     t0, t0, 26
    sra     t0, t0, 31
    and     t2, t3, t0          #   If not, no element added
    not     t0, t0
    and     t1, t4, t0          #   If so, element cleared
    or      t4, t1, t2          #   Determine field element

    andi    t0, s6, 0x0010      #   Spreads element to (target) tile?
    sll     t1, t0, 2           
    or      s0, s0, t1          #   Processing change byte
    lbu     t5, 0(s2)           #   (Target) tile element
    sll     t0, t0, 27
    sra     t0, t0, 31
    and     t2, t3, t0          #   If not, no element added
    not     t0, t0
    and     t1, t5, t0          #   If so, element cleared
    or      t5, t1, t2          #   Determine (target) tile element

    andi    t0, s6, 0x0008      #   Clears field element?
    sll     t1, t0, 4           
    or      s0, s0, t1          #   Processing change byte
    sll     t0, t0, 28
    sra     t0, t0, 31
    not     t0, t0
    and     t4, t4, t0
    sb      t4, 0(t6)           #   Store as processing flag (field element)

    andi    t0, s6, 0x0004      #   Clears (target) tile element?
    sll     t1, t0, 4           
    or      s0, s0, t1          #   Processing change byte
    sll     t0, t0, 29
    sra     t0, t0, 31
    not     t0, t0
    and     t5, t5, t0  
    sb      t5, 1(t6)           #   Store as processing flag ((target) tile element)

    andi    t0, s6, 0x0002      #   Causes unit vulnerability
    sll     t1, t0, 3           
    or      s0, s0, t1          #   Processing change byte
    sll     t0, t0, 30
    sra     t0, t0, 31
    and     t1, t3, t0
    or      s3, s3, t1          #   Modify unit vulnerability

    andi    t0, s6, 0x0001      #   Clears unit vulnerability?
    sll     t1, t0, 4           
    or      s0, s0, t1          #   Processing change byte
    sll     t0, t0, 31
    sra     t0, t0, 31
    not     t0, t0
    and     s3, s3, t0          #   Modify unit vulnerability
    sb      s3, 2(t6)           #   Store as processing flag (unit vulnerability)

    lbu     t7, 1(s4)           #   Critical?
    andi    t0, s6, 0x8000      #   Critical when unit is vulnerable?
    sll     t0, t0, 16
    sra     t0, t0, 31
    and     t1, s3, t3          #   Is unit vulnerable?
    sltu    t1, zero, t1        #   Is unit vulnerable? (0 or 1)
    and     t2, t1, t0          #   Add critical? (0 or 1)
    or      t7, t7, t2          #   Modify critical

    andi    t0, s6, 0x4000      #   Critical from field element?
    sltu    t0, zero, t0
    and     t1, t3, t4          #   Field element exists?
    sltu    t1, zero, t1
    and     t2, t0, t1          #   (And)
    or      t7, t7, t2          #   Modify critical

    lbu     t8, 0(s1)           #   (Source) tile element
    andi    t0, s6, 0x2000      #   Critical from (source) tile element?
    sltu    t0, zero, t0
    and     t2, t3, t8          #   (Source) tile element exists?
    sltu    t2, zero, t2
    and     t1, t0, t2          #   (And)
    or      t7, t7, t2          #   Modify critical
    sb      t7, 1(s4)           #   Store as critical

    #   The upcoming sections make use of set_action_mods, which does not overwrite temp (t) registers.
    #   t7 will now become the multiplier.

    li      t9, 0               #   Init: Bonus applied?
    lui     t7, 1               #   Multiplier: 3/2: 1.5: (..01.10..)
    ori     t7, t7, 0x8000

    andi    t0, s6, 0x1000      #   Bonus field element damage?
    and     t1, t3, t4          #   Field element exists?
    and     t2, t0, t1          
    sltu    t2, zero, t2        #   (And)
    or      t9, t9, t2    
    beq     t2, zero, aaf_pre_mod_1
    li      a3, 1
    jal     @set_action_mods
    move    a0, t7

    aaf_pre_mod_1:
        andi    t0, s6, 0x0800      #   Bonus (source) tile element damage?
        and     t1, t3, t8          #   (Source) tile element exists?
        and     t2, t0, t1
        sltu    t2, zero, t2        #   (And)
        or      t9, t9, t2
        beq     t2, zero, aaf_pre_mod_2
        li      a3, 1
        jal     @set_action_mods
        move    a0, t7

    aaf_pre_mod_2:
        andi    t0, s6, 0x0400      #   Bonus (target) tile element damage?
        and     t1, t3, t5          #   (Target) tile element exists?
        and     t2, t0, t1
        sltu    t2, zero, t2        #   (And)
        or      t9, t9, t2
        beq     t2, zero, aaf_pre_mod_3
        li      a3, 1
        jal     @set_action_mods
        move    a0, t7

    aaf_pre_mod_3:
        andi    t0, s6, 0x0200      #   Bonus unit vulnerability damage?
        and     t1, t3, s3          #   Unit vulnerability exists?
        and     t2, t0, t1
        sltu    t2, zero, t2        #   (And)
        or      t9, t9, t2
        beq     t2, zero, aaf_pre_mod_4
        li      a3, 1
        jal     @set_action_mods
        move    a0, t7

    aaf_pre_mod_4:
        andi    t0, s6, 0x0100      #   Status only applied during bonus?
        sltu    t0, zero, t0
        and     t0, t0, t9          #   AND: Was there a bonus?
        sll     t0, t0, 31
        sra     t0, t0, 31
        not     t0, t0
        addiu   t1, s4, 0x1b        #   Address of status infliction data
        
    li      t2, 0                   #   Loop counter
    status_loop_start:
            lbu     a1, 0(t1)       #   Load current status infliction byte
            nop
            and     a1, a1, t0      #   Clear if necessary
            sb      a1, 0(t1)       #   Store status byte
            
            addiu   t1, t1, 1       #   Increment variables and continue loop
            addiu   t2, t2, 1
            sltiu   a0, t2, 10
            bne     a0, zero, status_loop_start
            nop
    # --
    
    srl     s6, s6, 16              #   Use third set of flags
    lbu     t7, 1(s4)               #   t7 = Critical
    lw      t9, 0x40(sp)            #   t9 = Target unit index
    
    # 3rd set of checks
    
    andi    t0, s6, 0x0080          #   Acquires (target) tile element?
    sll     t0, t0, 24          
    sra     t0, t0, 31          
    and     t2, t5, t0              #   If not, no element added
    or      t3, t3, t2              #   Determine action element
    sb      t3, 0x38f7(s7)          #   Store as action element
    
    andi    t0, s6, 0x0040          #   Critical from (target) tile element?
    sltu    t0, zero, t0
    and     t2, t3, t5              #   (Target) tile element exists?
    sltu    t2, zero, t2
    and     t1, t0, t2              #   (And)
    or      t7, t7, t2              #   Modify critical
    sb      t7, 1(s4)               #   Store as critical
    
    andi    t0, s6, 0x0020          #   Spreads element to (source) tile?
    srl     t1, t0, 3           
    or      s0, s0, t1              #   Processing change byte
    sll     t0, t0, 26
    sra     t0, t0, 31
    and     t2, t3, t0              #   If not, no element added
    not     t0, t0
    and     t1, t8, t0              #   If so, element cleared
    or      t8, t1, t2              #   Determine (source) tile element
    
    andi    t0, s6, 0x0010          #   Clears (source) tile element?
    sll     t1, t0, 4           
    or      s0, s0, t1              #   Processing change byte
    sll     t0, t0, 27
    sra     t0, t0, 31
    not     t0, t0
    and     t8, t8, t0  
    sb      t8, 5(t6)               #   Store as processing flag ((source) tile element)
    
    andi    t0, s6, 0x0008          #   Creates elemental shield (append)?
    sll     t1, t0, 1
    or      s0, s0, t1              #   Processing change byte
    la      t2, @address_elemental_shield
    addu    t2, t2, t9              #   Base address + Target unit index
    lbu     t1, 0(t2)               #   Elemental shield
    sll     t0, t0, 28
    sra     t0, t0, 31
    and     t0, t0, t3
    or      t1, t1, t0              #   Modify elemental shield
    
    andi    t0, s6, 0x0004          #   Clears elemental shield?
    sll     t1, t0, 2
    or      s0, s0, t1              #   Processing change byte
    sll     t0, t0, 29
    sra     t0, t0, 31
    not     t0, t0
    and     t1, t1, t0              #   Modify elemental shield
    sb      t1, 3(t6)               #   Store as processing data (elemental shield)
    
    andi    t0, s6, 0x0002          #   Creates enchant element (overwrite)?
    sll     t1, t0, 2
    or      s0, s0, t1              #   Processing change byte
    la      t2, @address_enchant_element
    addu    t2, t2, t9              #   Base address + Target unit index
    lbu     t1, 0(t2)               #   Elemental enchant
    sll     t0, t0, 30
    sra     t0, t0, 31
    and     t2, t3, t0              #   Clear element to add if flag not set
    not     t0, t0
    and     t0, t1, t0              #   Clear current element if flag set
    or      t1, t0, t2              #   Modify elemental enchant (add element-to-add)
    
    andi    t0, s6, 0x0001          #   Clears elemental enchant?
    sll     t2, t0, 3
    or      s0, s0, t2              #   Processing change byte
    sll     t0, t0, 31
    sra     t0, t0, 31
    not     t0, t0
    and     t1, t1, t0              #   Modify enchant element
    sb      t1, 4(t6)               #   Store as processing data (enchant element)           
    
    # --
    
    sb      s0, 6(t6)               #   Store processing change byte
    
    # -- Return section --
    lw      s7, 36(sp)
    lw      s6, 32(sp)
    lw      s5, 28(sp)
    lw      s4, 24(sp)
    lw      s3, 20(sp)
    lw      s2, 16(sp)
    lw      s1, 12(sp)
    lw      s0, 8(sp)
    lw      ra, 4(sp)
    addiu   sp, sp, 44
    jr      ra
    nop
    # --

@apply_action_flags_post:
    
    addiu   sp, sp, -36
    sw      ra, 4(sp)
    sw      s0, 8(sp)
    sw      s1, 12(sp)
    sw      s2, 16(sp)
    sw      s3, 20(sp)
    sw      s4, 24(sp)
    sw      s5, 28(sp)
    sw      s6, 32(sp)
    
    la      s0, @address_processing_data
    
    lui     s1, 0x8019
    lw      s1, 0x2d98(s1)      #   Target unit
    
    #   Load processing data
    lbu     t0, 0(s0)           #   Field element        
    lbu     s2, 1(s0)           #   (Target) tile element
    lbu     t2, 2(s0)           #   Vulnerability
    lbu     s3, 3(s0)           #   Elemental shield
    lbu     s4, 4(s0)           #   Enchant element
    lbu     s5, 5(s0)           #   (Source) tile element
    lbu     s6, 6(s0)           #   Change flags
    
    aaf_post_field_element:
        andi    t3, s6, 0x80
        beq     t3, zero, aaf_post_vulnerability
        nop
        
        la      t1, @address_field_element
        sb      t0, 0(t1)
    
    aaf_post_vulnerability:
        andi    t3, s6, 0x40
        beq     t3, zero, aaf_post_tile_target
        nop
        
        sb      t2, 0x0169(s1) 
    
    aaf_post_tile_target:
        jal     @get_unit_element_address
        move    a0, s1
        
        andi    t3, s6, 0x20
        beq     t3, zero, aaf_post_shield
        nop
        
        sb      s2, 0(v0)
    
    aaf_post_shield:   
        jal     @find_unit_index
        move    a0, s1
    
        andi    t3, s6, 0x10
        beq     t3, zero, aaf_post_enchant
        nop
        
        la      t1, @address_elemental_shield
        add     t0, t1, v0
        sb      s3, 0(t0)
    
    aaf_post_enchant:
        andi    t3, s6, 0x08
        beq     t3, zero, aaf_post_tile_source
        nop
        
        la      t1, @address_enchant_element
        add     t0, t1, v0
        sb      s4, 0(t0)
    
    aaf_post_tile_source:
        andi    t3, s6, 0x04
        beq     t3, zero, aaf_post_end
        nop
    
        lui     a0, 0x8019
        lw      a0, 0x2d94(a0)
        jal     @get_unit_element_address
        nop
        sb      s5, 0(v0)
    
    aaf_post_end:
        lw      s6, 32(sp)
        lw      s5, 28(sp)
        lw      s4, 24(sp)
        lw      s3, 20(sp)
        lw      s2, 16(sp)
        lw      s1, 12(sp)
        lw      s0, 8(sp)
        lw      ra, 4(sp)
        addiu   sp, sp, 36
    
    jr      ra
    nop
    
# ROUTINE: Apply addend/multiplier to actions (Standard and return/drain action)
# Parameters: a0 = Multiplier (16.16 fixed point), a3 = Addend
#   NOTE: This routine does not modify temporary (t) registers.

@set_action_mods:
    
    addiu   sp, sp, -16
    sw      ra, 4(sp)
    sw      s0, 8(sp)
    sw      s3, 12(sp)
    
    move    s0, a0
    move    s3, a3
    
    #   Standard action
    lui     a1, 0x8019
    lw      a1, 0x2d90(a1)
    jal     @set_action_mod
    nop
    
    #   Return action (drain)
    lui     a1, 0x8019
    lw      a1, 0x2d8c(a1)
    move    a3, s3
    jal     @set_action_mod
    move    a0, s0
    
    lw      s3, 12(sp)
    lw      s0, 8(sp)
    lw      ra, 4(sp)
    addiu   sp, sp, 16
    
    jr      ra
    nop
    
# ROUTINE: Apply addend/multiplier to action
# Parameters: a0 = Multiplier (16.16 fixed point), a1 = Action, a3 = Addend
#   NOTE: This routine does not modify temporary (t) registers.

@set_action_mod:

    addiu   sp, sp, -20
    sw      ra, 4(sp)
    sw      s0, 8(sp)
    sw      s1, 12(sp)
    sw      s3, 16(sp)
    
    move    s0, a0
    move    s1, a1
    move    s3, a3

    #   HP Damage
    jal     @set_action_property_mod
    li      a2, 4  
    
    #   HP Healing
    move    a0, s0
    move    a1, s1
    move    a3, s3
    jal     @set_action_property_mod
    li      a2, 6
    
    #   MP Damage
    move    a0, s0
    move    a1, s1
    move    a3, s3
    jal     @set_action_property_mod
    li      a2, 8
    
    #   MP Healing
    move    a0, s0
    move    a1, s1
    move    a3, s3
    jal     @set_action_property_mod
    li      a2, 10
    
    lw      s3, 16(sp)
    lw      s1, 12(sp)
    lw      s0, 8(sp)
    lw      ra, 4(sp)
    addiu   sp, sp, 20
    
    jr      ra
    nop

# ROUTINE: Apply addend/multiplier to action property (offset)
# Parameters: a0 = Multiplier (16.16 fixed point), a1 = Action, a2 = Offset, a3 = Addend
#   NOTE: This routine does not modify temporary (t) registers.

@set_action_property_mod:

    add     at, a1, a2
    lhu     v0, 0(at)  
    nop
    
    addu    v1, v0, a3
    multu   v1, a0
    
    # Multiplying integer (32.0) by (16.16) fixed point gives (48.16) result
    # HI: [16 | 16], LO: [16 | 16]; Significant 32 bit integer part is the two middle 16s
    
    # a1: [ ZERO | LO LEFT 16 ]
    mflo    a1
    srl     a1, a1, 16
    
    # a2: [ HI RIGHT 16 | ZERO ]
    mfhi    a2
    sll     a2, a2, 16
    
    # v0: [ HI RIGHT 16 | LO LEFT 16 ]
    or      v0, a2, a1
    
    jr      ra
    sh      v0, 0(at)    

# ROUTINE: Get element address from unit's tile
# Parameters: a0 = Unit
    
@get_unit_element_address:

    la      v0, @address_tile_element

    lbu     t4, 0x47(a0)        #   t4 = Unit X
    lbu     t6, 0x49(a0)        
    lbu     t5, 0x48(a0)        #   t5 = Unit Y

    andi    t6, t6, 0x80        #   t6 = Unit U = IsOnUpperLevel

    sll     t7, t5, 2           #   Y * 4
    add     t7, t7, t5          #   Y * 5
    sll     t7, t7, 2           #   Y * 20

    sll     t8, t6, 1           #   U * 2
    add     t8, t8, t6          #   U * 3
    sll     t8, t8, 3           #   U * 24
    add     t8, t8, t6          #   U * 25
    sll     t8, t8, 4           #   U * 400

    add     t9, t4, t5
    add     t9, t9, t8          #   Offset for tile element: (U * 400) + (Y * 20) + X

    jr      ra
    addu    v0, v0, t9
    
# ROUTINE: Get element from unit's tile
# Parameters: a0 = Unit

@get_unit_element:
    addiu   sp, sp, -8
    sw      ra, 4(sp)
    
    jal     @get_unit_element_address
    nop
    lbu     v0, 0(v0)           #   Return tile element
    
    lw      ra, 4(sp)
    addiu   sp, sp, 8
    jr      ra
    nop

# ROUTINE: Get unit enchant element
# Parameters: a0 = Unit

@get_unit_enchant_element:
    addiu   sp, sp, -8
    sw      ra, 4(sp)
    
    jal     @find_unit_index
    nop
    
    la      t0, @address_enchant_element
    addu    t0, t0, v0
    lbu     v0, 0(t0)
    
    lw      ra, 4(sp)
    addiu   sp, sp, 8
    jr      ra
    nop
    
# ROUTINE : Create elemental shield
# Parameters: a0 = Unit, a1 = Element(s)
    
@create_elemental_shield:    

    addiu   sp, sp, -12
    sw      ra, 4(sp)
    sw      s1, 8(sp)
    
    move    s1, a1
    jal     @find_unit_index
    nop
    
    la      t0, @address_elemental_shield
    addu    t0, t0, v0
    lbu     t1, 0(t0)
    nop
    or      t1, t1, s1
    sb      t1, 0(t0)
    
    lw      s1, 8(sp)
    lw      ra, 4(sp)
    addiu   sp, sp, 12
    jr      ra
    nop

# ROUTINE : Clear elemental shield
# Parameters: a0 = Unit

@clear_elemental_shield:
    
    addiu   sp, sp, -8
    sw      ra, 4(sp)
    
    jal     @create_elemental_shield
    li      a1, 0
    
    lw      ra, 4(sp)
    addiu   sp, sp, 8
    jr      ra
    nop
    
# ROUTINE: Apply elemental shield
@apply_elemental_shield:

    addiu   sp, sp, -12
    sw      s0, 8(sp)
    sw      ra, 4(sp)
    
    # Find unit index
    lui     s0, 0x8019
    lw      a0, 0x2d94(s0)
    jal     @find_unit_index
    nop
    
    # Load elemental shield (and ability element)
    la      t0, @address_elemental_shield
    addu    t0, t0, v0
    lbu     t1, 0(t0)
    lbu     t2, 0x38f7(s0)
    nop
    
    # Skip to end if this element is not shielded
    and     t3, t1, t2
    beq     t3, zero, aes_end
    nop
    
    # If the element is shielded, apply 1/2 multiplier
    li      a0, 0x8000      #   (..00.10..) 16.16 fixed point
    jal     @set_action_mods
    li      a3, 1           #   Addend = 1
    
    aes_end:
        lw      s0, 8(sp)
        lw      ra, 4(sp)
        addiu   sp, sp, 12
        
    jr      ra
    nop
    
# ROUTINE: Find unit index
# Parameters: a0 = Unit

@find_unit_index:

    lui     t0, 0x8019
    ori     t0, t0, 0x08cc      #   Start of unit data
    subu    t1, a0, t0          #   (Target unit pointer) - (Start of unit data)
    li      t2, 0x1c0       
    div     t1, t2              #   / (Size of unit in bytes)
    mflo    v0                  #   Target unit index
    jr      ra
    nop
    
# ROUTINE: Apply (negative) elemental status
#   NOTE: Makes use of @apply_elemental_status_worker, which changes no registers.
@apply_elemental_status_negative:
    
    addiu   sp, sp, -8
    sw      ra, 4(sp)
    
    lui     v1, 0x8019
    lbu     a3, 0x38f7(v1)      #   Action element
    lbu     v1, 0x2d90(v1)      #   Action
    
    #   Fire -> Death sentence
    addiu   a0, v1, 0x1f
    li      a1, 7
    jal     @apply_elemental_status_worker
    li      a2, 0x01

    #   Water -> Sleep
    li      a1, 4
    jal     @apply_elemental_status_worker
    li      a2, 0x10
    
    #   Earth -> Don't Move
    li      a1, 3
    jal     @apply_elemental_status_worker
    li      a2, 0x08
    
    #   Lightning -> Silence
    addiu   a0, v1, 0x1c
    li      a1, 6
    jal     @apply_elemental_status_worker
    li      a2, 0x08
    
    #   Wind -> Confusion
    li      a1, 5
    jal     @apply_elemental_status_worker
    li      a2, 0x10
    
    #   Holy -> Petrify
    li      a1, 1
    jal     @apply_elemental_status_worker
    li      a2, 0x80
    
    #   Ice -> Slow
    addiu   a0, v1, 0x1e
    li      a1, 2
    jal     @apply_elemental_status_worker
    li      a2, 0x04
    
    #   Dark -> Stop
    li      a1, 0
    jal     @apply_elemental_status_worker
    li      a2, 0x02
    
    lw      ra, 4(sp)
    addiu   sp, sp, 8
    jr      ra
    nop

    
# ROUTINE: Apply (positive) elemental status
@apply_elemental_status_positive:
    
    addiu   sp, sp, -8
    sw      ra, 4(sp)
    
    lui     v1, 0x8019
    lbu     a3, 0x38f7(v1)      #   Action element
    lbu     v1, 0x2d90(v1)      #   Action
    
    #   Fire -> Reraise
    addiu   a0, v1, 0x1d
    li      a1, 7
    jal     @apply_elemental_status_worker
    li      a2, 0x20
    
    #   Dark -> Transparent
    li      a1, 0
    jal     @apply_elemental_status_worker
    li      a2, 0x10

    #   Lightning -> Attune (Faith)
    addiu   a0, v1, 0x1f
    li      a1, 6
    jal     @apply_elemental_status_worker
    li      a2, 0x80
    
    #   Ice -> Reflect
    li      a1, 2
    jal     @apply_elemental_status_worker
    li      a2, 0x02
    
    #   Wind -> Haste
    addiu   a0, v1, 0x1e
    li      a1, 5
    jal     @apply_elemental_status_worker
    li      a2, 0x08
    
    #   Water -> Shell
    li      a1, 4
    jal     @apply_elemental_status_worker
    li      a2, 0x10
    
    #   Earth -> Protect
    li      a1, 3
    jal     @apply_elemental_status_worker
    li      a2, 0x20
    
    #   Holy -> Regen
    li      a1, 1
    jal     @apply_elemental_status_worker
    li      a2, 0x40
    
    lw      ra, 4(sp)
    addiu   sp, sp, 8
    jr      ra
    nop
    
# ROUTINE: Apply elemental status worker function
    # Parameters: a0=Status inflict byte pointer, a1=Element flag bit (from right) [0..7], a2=Status-to-Add, a3=Action element
    #   Changes no registers.
@apply_elemental_status_worker:
    
    addiu   sp, sp, -24
    sw      at, 4(sp)
    sw      v0, 8(sp)
    sw      v1, 12(sp)
    sw      a1, 16(sp)
    sw      a2, 20(sp)

    li      at, 1
    sllv    at, at, a1      #   Element to check
    li      v1, 31
    subu    a1, v1, a1      #   Bit from right
    
    lbu     v0, 0(a0)       #   Status inflict byte
    and     v1, a3, at      #   Is element present?
    sllv    v1, v1, a1
    sra     v1, v1, 31
    and     a2, a2, v1      #   Blank Status-to-Add if element not present
    or      v0, v0, a2      #   Append Status-to-Add to status inflict byte
    sb      v0, 0(a0)       #   Store as status inflict byte
    
    lw      a2, 20(sp)
    lw      a1, 16(sp)
    lw      v1, 12(sp)
    lw      v0, 8(sp)
    lw      at, 4(sp)
    addiu   sp, sp, 24
    jr      ra
    nop
    
# Other routines

# ROUTINE: Calculate MA * (WP + Y) for formulas

@calc_weapon_damage_MA:
    lui     a1,0x8019
    lw      a0,0x2d94(a1)
    lbu     v0,0x3902(a1)       # WP
    lbu     v1,0x38fa(a1)       # Ability Y
    lbu     a0,0x0037(a0)       # MA
    addu    v0,v0,v1            # (WP + Y)
    sh      v0,0x38d0(a1)       # YA = (WP + Y)
    sh      a0,0x38ce(a1)       # XA = MA
    jr      ra
    nop

# ROUTINE: Feedback formula

@formula_feedback:
      
    addiu   sp, sp, -0x18
    sw      ra, 0x10(sp)
    
    jal     0x188510                # Physical Evade Calculation
    nop                             
    bne     v0, zero, feedback_end  # If Evaded, Skip           
    nop
    
    jal     0x185c94                # Get Ability Power
    nop
    jal     0x188964                # Calculate MA * Y Damage
    nop
    
    lui     t0, 0x8019 
    lw      v0, 0x2d98(t0)
    lw      v1, 0x2d90(t0)
    nop
    
    lhu     t0, 4(v1)               # Load HP Damage
    lhu     a0, 0x2c(v0)            # Load target MP
    li      v0, 0xa0
    
    slt     t1, a0, t0
    beq     t1, zero, feedback_store
    nop
    
    move    t0, a0                      # Cap damage at target MP
    
    feedback_store:
        sb      v0, 0x25(v1)            # Save Action Type = HP Damage + MP Damage
        sh      t0, 0x08(v1)            # Save MP Damage = Capped damage
        sh      t0, 0x04(v1)            # Save HP Damage = Capped damage
      
    feedback_end:  
        lw      ra, 0x10(sp)
        addiu   sp, sp, 0x18
        
    jr      ra
    nop

# ROUTINE: Physical formula: (PA+Y) * WP, Hit: X%, PE
@formula_physical:

    addiu   sp, sp, -8
    sw      ra, 4(sp)

    jal     0x188510                #   Physical evade
    nop
    beq     v0, zero, formula_physical_end
    nop
    
    jal     @formula_hit_percent_x
    nop
    beq     v0, zero, formula_physical_end
    nop
    
    jal     0x185e5c                #   Load WP + Y as XY
    nop
    jal     0x1886a4                #   Damage: PA * (WP + Y)
    nop
    jal     0x187eb4                #   Status proc
    nop
    
    formula_physical_end:
        lw      ra, 4(sp)
        addiu   sp, sp, 8
        
    jr      ra
    nop
    
# ROUTINE: Element rotation formula    
@formula_element_rotation:

    addiu   sp, sp, -8
    sw      ra, 4(sp)

    lui     a0, 0x8019
    lw      a0, 0x2d94(a0)      #   Parameter a0 = Source
    jal     @get_unit_element_address
    nop

    lbu     t0, 0(v0)           #   Source tile element
    nop
    
    beq     t0, zero, fer_end
    nop
    
    #   If no source tile element, randomize element
    jal     @get_random_positive_integer
    li      a0, 8               #   v0 = Random integer [0..7]
    
    li      t0, 1               #   Start with 1, and...
    sllv    v0, t0, v0          #   Shift by random integer amount (Result is one of 0x01, 0x02, 0x04, etc, up to 0x80)
    
    lui     t0, 0x8019
    sb      v0, 0x38f7(t0)      #   Save as action element

    fer_end:
        lw      ra, 4(sp)
        addiu   sp, sp, 8
        
    jr      ra
    nop
    
@formula_hit_percent_x:
    
    addiu   sp, sp, -0x18
    sw      ra, 0x10(sp)
    
    lui     t0, 0x8019
    lbu     a1, 0x38f9(t0)		    #   Load Ability X
    lw      t2, 0x2d90(t0)
    nop
    sb      a1, 0x2a(t2)		    #   Save [Hit %] = X
    jal     0x5e0cc			        #   Roll (0-99) with threshold = X (X% under)
    li      a0, 100
    lui     t0, 0x8019
    lw      t1, 0x2d90(t0)
    sltiu   v0, v0, 1			    #   Result = 1 if roll was under threshold (success), otherwise 0
    sb      v0, 0(t1)		        #   Save result

    bne     v0, zero, fhpx_return   #   If missed, set action's evade type to Miss
    nop
    li      a0, 6
    sb      a0, 2(t1)

    fhpx_return:
        lw      ra, 0x10(r29)
        addiu   sp, sp, 0x18
        
    jr      ra				# Return result
    nop

# ROUTINE: Apply vulnerability
@apply_vulnerability:

    addiu   sp, sp, -8
    sw      ra, 4(sp)

    lui     t0, 0x8019
    lw      t1, 0x2d98(t0)
    lbu     t2, 0x38f7(t0)
    lbu     t3, 0x0169(t1)
    nop
    and     t4, t3, t2
    beq     t4, zero, vuln_end      #   If Not (target[0x0169] AND abilityElement), return
    lui     a0, 1
    
    ori     a0, a0, 0x8000          #   Multiplier = 1.5 (..01.10..) 16.16 fixed point
    jal     @set_action_mods
    li      a3, 1  
    
    vuln_end:
        lw      ra, 4(sp)
        addiu   sp, sp, 8
    
    jr      ra
    nop
    
# ROUTINE: Apply attune/wane (for both source and target units)
@apply_attune_wane:

    addiu   sp, sp, -12
    sw      ra, 4(sp)
    sw      s0, 8(sp)

    lui     t0, 0x8019
    lw      a0, 0x2d98(t0)
    lw      s0, 0x2d94(t0)
    
    jal     @apply_attune_wane_unit
    nop
    
    jal     @apply_attune_wane_unit
    move    a0, s0
    
    lw      s0, 8(sp)
    lw      ra, 4(sp)
    addiu   sp, sp, 12
    
    jr      ra
    nop
    
# ROUTINE: Apply attune/wane (based on unit)
#   PARAMETERS: a0 = Unit

@apply_attune_wane_unit:

    addiu   sp, sp, -12
    sw      ra, 4(sp)
    sw      s0, 8(sp)
    
    lui     t0, 0x8019
    lbu     t1, 0x38f7(t0)          #   Action element
    nop
    
    beq     t1, zero, aaw_end
    nop
    
    lbu     s0, 0x5c(a0)            #   Current statuses 5
    nop
    
    aaw_attune_check:
        andi    t4, s0, 0x80            #   Attune check
        beq     t4, zero, aaw_wane_check
        nop
        
        lui     a0, 1
        ori     a0, a0, 0x8000          #   Multiplier = 1.5 (..01.10..) 16.16 fixed point
        jal     @set_action_mods
        li      a3, 1                   #   Addend = 1
        
    aaw_wane_check:
        andi    t4, s0, 0x40
        beq     t4, zero, aaw_end
        nop
            
        li      a0, 0x8000              #   Multiplier = 0.5 (..00.10..) 16.16 fixed point
        jal     @set_action_mods
        li      a3, 1                   #   Addend = 1
        
    aaw_end:
        lw      s0, 8(sp)
        lw      ra, 4(sp)
        addiu   sp, sp, 12
        
    jr      ra
    nop
    
# ROUTINE: Formula tail routine
    
@formula_tail:

    addiu   sp, sp, -8
    sw      ra, 4(sp)
    
    # jal     @apply_damage_healing_multipliers
    # nop
    jal     @apply_action_flags_pre
    nop
    jal     @apply_crit
    nop
    jal     @apply_elemental        
    nop
    jal     @apply_vulnerability
    nop
    jal     @apply_elemental_shield
    nop
    jal     @apply_attune_wane
    nop

    lw      ra, 4(sp)
    addiu   sp, sp, 8
    jr      ra
    nop
    
# ROUTINE: Clear vulnerability/aura from unit in v1
#   NOTE: This routine uses (v1) as a parameter!

@clear_vuln_aura:
    sb      zero,0x0169(v1)         #   Remove vulnerability
    jr      ra
    sb      zero,0x016b(v1)         #   Remove aura
    
# ROUTINE: Conditionally clear vulnerability
 
@clear_vuln_cond:
    lui     t0,0x8019
    lbu     t1,0x38fb(t0)           #   Inflict Status ID
    li      t2,0x26   
    bne     t1,t2,cvc_end           #   Skip if not 0x26
    nop

    lw      t3,0x2d98(t0)
    nop
    sb      zero,0x0169(t3)         #   Zero out vulnerability
    
    cvc_end:
        jr      ra
    nop
    
# ROUTINE: Formula for Aura Surge abilities (0x18)

@formula_aura_surge:

    addiu   sp,sp,-0x18     
    sw      ra,0x10(sp)

    lui     t0,0x8019       
    lw      t1,0x2d94(t0)   
    lbu     t3,0x38f7(t0)         # Element
    lbu     t2,0x016b(t1)         # Aura
    lhu     t7,0x38d6(t0)         # Ability ID
    srl     t5,t3,6               # 2 = fire, 1 = lightning, 0 = ice
    sll     t7,t7,1
    li      t9,0x801b63f0
    addu    t9,t9,t7              # Load effect (animation) address
    andi    t4,t2,0x40      
    bne     t4,zero,formula_aura_on     # Skip to formula_aura_on if aura is active
    sll     t6,t5,1         

    lw      a0,0x2d90(t0)         # Load Action
    li      a1,6
    sb      zero,0x00(a0)         # Action misses
    sb      a1,0x02(a0)           # Action evade type = Missed
    sb      zero,0x2a(a0)         # Action displayed hit = 00%
    li      t8,0xffff
    j       formula_aura_end
    sh      t8,0(t9)              # Action animation = Blank

    formula_aura_on:   
        srlv    t4,t2,t6
        andi    t4,t4,0x03            # Level of aura for this element (0-3)

        li      t7,2
        subu    t6,t7,t5
        sll     t6,t6,2
        addu    t6,t6,t4
        addiu   t6,t6,0x10
        sh      t6,0(t9)              # Save effect (animation) = 0x10 + (0=fire, 4=bolt, 8=ice) + Aura level

        sll     t7,t4,2
        addiu   t7,t7,16
        sb      t7,0x38fa(t0)         # Ability Y = (Aura element level (0-3)) * 4 + 16 (16,20,24,28)

        jal     0x188d84              # Dmg_F(MA*Y) ME
        nop

    formula_aura_end:  
        lw      ra,0x10(r29)
        addiu   sp,sp,0x18
        
    jr      ra
    nop
    
# ROUTINE: Formula aura blast (0x19)

@formula_aura_blast:

    addiu   sp,sp,-0x18
    sw      ra,0x10(sp)

    lui     t0,0x8019
    lw      t1,0x2d94(t0)             
    lhu     t7,0x38d6(t0)         # Ability ID
    lbu     t2,0x016b(t1)         # Aura
    sll     t7,t7,1
    li      t9,0x801b63f0
    addu    t9,t9,t7              # Load effect (animation) address

    andi    t4,t2,0x40
    bne     t4,zero,fab_on        # Skip to fab_on if aura is active
    srl     t5,t2,4

    lw      a0,0x2d90(t0)         # Load Action
    li      a1,6
    sb      zero,0x00(a0)         # Action misses
    sb      a1,0x02(a0)           # Action evade type = Missed
    sb      zero,0x2a(a0)         # Action displayed hit = 00%
    li      t8,0xffff
    j       fab_end
    sh      t8,0(t9)              # Action animation = Blank

    fab_on:   
        andi    t5,t5,0x03            # Level of aura for fire (0-3)
        srl     t6,t2,2
        andi    t6,t6,0x03            # Level of aura for lightning (0-3)
        andi    t7,t2,0x03            # Level of aura for ice (0-3)

        addu    t3,t5,t6
        addu    t3,t3,t7
        sll     t4,t3,1
        addiu   t4,t4,16
        sb      t4,0x38fa(t0)         # Ability Y = (Sum of aura levels) * 2 + 16 (16,18,20,22,24,26,28,30,32,34)

        li      t8,0x00a0             
        sh      t8,0(t9)              # Set animation

        jal     0x188d84              # Dmg_F(MA*Y) ME
        nop

    fab_end:  
        lw      ra,0x10(r29)
        addiu   sp,sp,0x18
        
    jr      ra
    nop

#   ROUTINE: Post-actions for aura
@aura_post:  
    
    addiu   sp, sp, -8
    sw      ra, 4(sp)
    
    lui     t0,0x8019
    lw      t1,0x2d94(t0)
    lbu     t2,0x38f8(t0)         # Ability Formula
    lhu     t3,0x38d6(t0)         # Ability ID
    lbu     t5,0x016b(t1)         # Aura
    
    lbu     t4,0x38f7(t0)         # Element

    li      t6,0x18
    bne     t2,t6,fpost_C19       # Skip to fpost_C19 (Check 0x19) if formula isn't 0x18
    li      t6,0x19

    srl     t7,t4,6
    sll     t7,t7,1
    srlv    t8,t5,t7
    andi    t8,t8,0x03            # Level of aura for this element (0-3)

    sltiu   t9,t8,3
    addu    t9,t8,t9              # Add 1 to aura level if less than 3            

    xor     t9,t8,t9
    sllv    t9,t9,t7
    xor     t9,t9,t5
    sb      t9,0x016b(t1)         # Save new aura with new level for this element

    fpost_C19:  
        bne     t2,t6,fpost_CID             # Skip to CID (Check ID) if formula isn't 0x19
        li      t6,0x016b

        sb      zero,0x016b(t1)       # Save aura as blank/inactive

    fpost_CID:  
        bne     t3,t6,fpost_END             # Return if ability ID is not 0x016b (Arcane Aura)
        li      t7,0x40

        sb      t7,0x016b(t1)         # Save aura as new (active) aura, all elements level 0

    fpost_END:  
        jal     @clear_vuln_cond
        nop
  
    lw      ra, 4(sp)
    addiu   sp, sp, 8
    jr      ra
    nop
    
# ROUTINE: Determine aura effect area
@aura_effect_area:

    lui     t0,0x8019
    lbu     t7,8(v0)                #   Ability Formula
    li      t8,0x18
    bne     t7,t8,aea_end           #   Skip to end if formula isn't 0x18
    nop

    lbu     t3,7(v0)                #   Element
    lbu     t2,0x016b(s4)           #   Aura
    srl     t5,t3,6                 #   t5: 2 = fire, 1 = lightning, 0 = ice
    andi    t4,t2,0x40
    beq     t4,zero,aea_end         #   Skip to aea_end if aura is inactive
    sll     t6,t5,1

    lbu     a3,1(v0)
    srlv    a3,t2,t6
    andi    a3,a3,0x03              #   Level of aura for this element (0-3)      
    sltiu   t9,a3,3
    sltiu   t9,t9,1
    subu    a3,a3,t9                #   Cap effect area at 2
    sb      a3,1(v0)                #   Ability Effect Area = Aura Level

    aea_end:  
        jr      ra
    nop

# ROUTINE: Post action
@action_post:
    addiu   sp, sp, -8
    sw      ra, 4(sp)
    jal     @apply_action_flags_post
    nop
    jal     @aura_post
    nop
    jal     @clear_elements
    nop
    lw      ra, 4(sp)
    addiu   sp, sp, 8
    jr      ra
    nop
    
# ROUTINE: Clear elements
@clear_elements:    
    lui     t0, 0x8019
    sb      zero, 0x3904(t0)        #   Zero out weapon element
    jr      ra
    sb      zero, 0x38f7(t0)        #   Zero out ability element
    
# ROUTINE: Get random positive integer in range [0, a0)
@get_random_positive_integer:

    addiu   sp, sp, -12
    sw      ra, 4(sp)
    sw      s0, 8(sp)

    move    s0, a0
    
    jal     0x2230c		            #   Random Number Generator
    nop
    
    mult    v0, s0
    mflo    v0
    
    bgez    v0, grpi_shift		    #   If (Number is negative)
    nop
    addiu   v0, v0, 0x7fff          #       Make it positive
    
    grpi_shift:
        sra     v0, v0, 0x0f		#   Rand [0..a0)
    
    lw      s0, 8(sp)
    lw      ra, 4(sp)
    addiu   sp, sp, 12
    jr      ra
    nop

# ROUTINE: Apply crit
@apply_crit:

    addiu   sp, sp, -12
    sw      ra, 4(sp)
    sw      s0, 8(sp)

    lui     s0, 0x8019
    lw      s0, 0x2d90(s0)                  #   Action
    nop

    lh      t0, 4(s0)                       #   HP Damage
    nop

    beq     t0, zero, crit_end              #   Return if HP Damage = 0
    nop

    lbu     t0, 1(s0)
    nop
    bne     t0, zero, crit_end              #   If crit already set, keep it
    li      a0, 100
    
    jal     0x18eed8                        #   Roll for crit
    li      a1, 4

    bne     v0, zero, crit_end              #   Return if no crit
    li      v1, 1
    jal     0x18eea0                        #   Roll crit multiplier
    sb      v1, 1(s0)

    # HP Damage
    move    a2, s0
    move    s0, v0
    li      a0, 4
    move    a1, s0
    jal     @crit_action_mod

    # Returned HP Healing (Drain)
    li      a0, 6
    move    a1, s0
    lui     a2, 0x8019
    lw      a2, 0x2d8c(a2)
    jal     @crit_action_mod
    nop
    
    jal     0x1843ec                        #   Knockback
    nop
        
    crit_end:
        lw      s0, 8(sp)                   #   Return
        lw      ra, 4(sp)
        addiu   sp, sp, 12
        
    jr      ra
    nop
    
# Routine: Apply crit action mod to offset
#   Parameters: a0 = Offset, a1 = Multiplier, a2 = Action
@crit_action_mod:

    lui     t0, 0x8019
    lw      t1, 0x2d90(t0)
    nop
    
    addu    t2, t1, a0
    lhu     t3, 0(t2)
    nop
    
    mult    t3, a1                          #   HP Damage * Crit multiplier
    mflo    v0
    bgez    v0, cam_past_negative_check     #   IF (Result is negative) {
    nop

    addiu   v0, v0, 0x7fff                  #       Make it positive
                                            #   }
    cam_past_negative_check:                
        sra     v0, v0, 15
        addu    v0, t3, v0                  #   Add to original
        sh      v0, 0(t2)                   #   Save as HP Damage
        
    jr      ra
    nop

# ROUTINE: Pre-battle tail
@pre_battle_tail:

    addiu   sp, sp, -8
    sw      ra, 4(sp)
    
    jal     @clear_element_data
    nop
    
    lw      ra, 4(sp)
    addiu   sp, sp, 8
    jr      ra
    nop
    
# ROUTINE: Clear element data.  Should be run at battle start.
@clear_element_data:
    
    addiu   sp, sp, -8
    sw      ra, 4(sp)
    
    la      a0, @address_field_element 
    sb      zero, 0(a0)
    
    la      a0, @address_tile_element
    jal     @clear_data_block
    li      a1, 800      
    
    la      a0, @address_processing_data
    jal     @clear_data_block
    li      a1, 0x10 
    
    la      a0, @address_elemental_shield
    jal     @clear_data_block
    li      a1, 0x20 
    
    la      a0, @address_enchant_element
    jal     @clear_data_block
    li      a1, 0x20 
    
    lw      ra, 4(sp)
    addiu   sp, sp, 8
    jr      ra
    nop

    </Location>
    <Location file="BATTLE_BIN" offset="125308" mode="ASM">
      jal     @clear_vuln_aura      # Remove aura/vulnerability when KOed
    </Location>
    <Location file="BATTLE_BIN" offset="125588" mode="ASM">
      jal     @clear_vuln_aura      # Remove aura/vulnerability when KOed
    </Location>
    <Location file="BATTLE_BIN" offset="113304" mode="ASM">
      # Effect area determination (Routine: 0x17a290) (Specific: 0x17a304)
      # Can get away with this because 0x15d530 sets effect area
      jal     @aura_effect_area     # Call new routine
    </Location>
    <Location file="BATTLE_BIN" offset="189164" offsetMode="RAM" mode="ASM">
      # Formula 0x13
      j       @formula_element_rotation   # Jump to new section
    </Location>
    <Location file="BATTLE_BIN" offset="12229C" mode="ASM">
      # Formula 0x18
      j       @formula_aura_surge   # Jump to new section
    </Location>
    <Location file="BATTLE_BIN" offset="1222A4" mode="ASM">
      # Formula 0x19
      j       @formula_aura_blast   # Jump to new section
    </Location>
    <Location file="BATTLE_BIN" offset="11FD58" mode="ASM">
      # Formula 0x3B
      j       @formula_feedback
      nop
    </Location>
    <Location file="BATTLE_BIN" offset="18A218" offsetMode="RAM" mode="ASM">
      # Formula 0x46
      j       @formula_physical
    </Location>
    <Location file="BATTLE_BIN" offset="1249F0" mode="ASM">
      j       @formula_tail
    </Location>
    <Location file="BATTLE_BIN" offset="F5E60" mode="ASM">
      # Elemental override
      j       @action_post
      nop
    </Location>
    <Location file="SCUS_942_21" offset="4CA58" mode="ASM">
      # Zero out vuln/aura when battle starts
      jal     @clear_vuln_aura_battle_start
      nop
      lw      s4,0x20(sp)
      lw      ra,0x24(sp)
    </Location>
    <Location file="BATTLE_BIN" offset="F60C0" mode="ASM">
      @clear_vuln_aura_battle_start:
          lw      s3,0x1c(sp)
          lw      s2,0x18(sp)
          sb      zero,0x0169(s0)       # Zero out 0x169 (vulnerabilities)
          jr      ra
          sb      zero,0x016b(s0)       # Zero out 0x16b (aura)
    </Location>
    <Location file="BATTLE_BIN" offset="1864F8" mode="ASM" offsetMode="RAM">
        # Blanking out normal crit routine
        jr      ra
        nop
    </Location>
    <Location file="SCUS_942_21" offset="42A08" mode="ASM" offsetMode="RAM">
        # Pre-battle hook
        j       @pre_battle_tail
    </Location>
  </Patch>
</Patches>